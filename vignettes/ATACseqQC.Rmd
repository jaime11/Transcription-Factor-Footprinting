---
title: "ATACseqQC Guide"
author: "Jianhong Ou, Jun Yu, Lucio Castilla, Nathan Lawson, Lihua Julie Zhu"
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('ATACseqQC')`"
bibliography: bibliography.bib
csl: nature.csl
vignette: >
  %\VignetteIndexEntry{ATACseqQC Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document
---

```{r, echo=FALSE, results="hide", warning=FALSE, message=FALSE}
suppressPackageStartupMessages({
  library(ATACseqQC)
  library(ChIPpeakAnno)
  library(BSgenome.Hsapiens.UCSC.hg19)
  library(TxDb.Hsapiens.UCSC.hg19.knownGene)
  library(phastCons100way.UCSC.hg19)
  library(MotifDb)
})
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```

# Introduction

Assay for Transposase-Accessible Chromatin using sequencing 
(ATAC-seq) is a alternative or complementary technique to MNase-seq 
(sequencing of micrococcal nuclease sensitive sites). It is rapid and
sensitive method for chromatin accessibility analysis. We collect 
codes for ATAC-seq analysis following the report of 
Greenleaf Lab[@buenrostro2013transposition],
in order to help users to do quick quality control for their data,
which including fragment size distribution, nucleosome positioning,
and CTCF or other Transcript Factor footprints.

# Quick start

Here is an example to use ATACseqQC for a subset of ATAC-seq 
data[@buenrostro2013transposition]. The input of the package should be bam file.

```{r}
## load the library
library(ATACseqQC)
## input is bamFile
bamfile <- system.file("extdata", "GL1.bam", 
                        package="ATACseqQC", mustWork=TRUE)
bamfile.labels <- gsub(".bam", "", basename(bamfile))
```

## Fragment size distribution

The insert size distribution of sequenced fragments from chromatin should have 
clear periodicity of fixed bps, suggesting many fragments are 
protected by integer multiples of nucleosomes.  
Inset, log-transformed histogram will show clear periodicity. The more periodic 
peaks you see in the inset figure, the better quality of your example shows.

```{r}
## generate fragement size distribution
fragSize <- fragSizeDist(bamfile, bamfile.labels)
```

## Nucleosome positioning

### Adjust the read start sites

For downstream analyze, for example peak-calling and footprinting,
all reads in input bamfile will be shifted.
All reads aligning to the positive strand will be offset by +4bp, 
and all reads aligning to the negative strand will be offset -5bp.

We will keep the tags in original bamfile and export the adjusted reads
into a new bamfile for peak calling or footprinting.

```{r}
## bamfile tags
tags <- c("AS", "XN", "XM", "XO", "XG", "NM", "MD", "YS", "YT")
## files will be output into outPath
outPath <- "splited"
dir.create(outPath)
## shift the bam file by the 5'ends
library(BSgenome.Hsapiens.UCSC.hg19)
seqlev <- "chr1" ## subsample data for quick run
which <- as(seqinfo(Hsapiens)[seqlev], "GRanges")
gal <- readBamFile(bamfile, tag=tags, which=which, asMates=TRUE)
gal1 <- shiftGAlignmentsList(gal)
shiftedBamfile <- file.path(outPath, "shifted.bam")
export(gal1, shiftedBamfile)
```

### Split reads

The shifted reads will be splitted into alignments only including 
nucleosome free, mononucleosome, dinucleosome or trinucleosome. 
Spliting the reads is a time consuming step because we are using 
random forest to predict the clusification based on fragment length,
GC content and conservation scores[@chen2013danpos].

By default, we use top coverage region of nucleosome free (reads below 100bp)
and mononucleosome (reads between 180 and 247bp) as training set to predict
the probability of the fragment belonging to nucleosome free or not by random
forest. The number of the tree will be set to 2 times of square root of
the length of training set.

```{r}
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txs <- transcripts(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(phastCons100way.UCSC.hg19)
## run program for chromosome 1 only
txs <- txs[seqnames(txs) %in% "chr1"]
genome <- Hsapiens
## split the reads into NucleosomeFree, mononucleosome, 
## dinucleosome and trinucleosome.
objs <- splitGAlignmentsByCut(gal1, txs=txs, genome=genome,
                              conservation=phastCons100way.UCSC.hg19)
```

Save the splitted reads into bam files.

```{r}
null <- writeListOfGAlignments(objs, outPath)
## list the files generated by splitBam.
dir(outPath)
```

You can also do shift, split and save bams in one step by calling `splitBam`.

```{r eval=FALSE}
objs <- splitBam(bamfile, tags=tags, outPath=outPath,
                 txs=txs, genome=genome,
                 conservation=phastCons100way.UCSC.hg19)
```

### Heatmap and coverage curve for nucleosome positions

By averaging signal across all active TSSs, nucleosome-free fragments should
be enriched at a canonical nucleosome-free promoter region overlapping the TSS, 
whereas the nucleosome signal should be enriched both upstream and downstream 
of the active TSS and displayed characteristic phasing of upstream and 
downstream nucleosomes. Because ATAC-seq reads are concentrated at regions of 
open chromatin, users should saw a strong nucleosome signal at the +1 
nucleosome that decreased at the +2, +3 and +4 nucleosomes. 

```{r fig.height=4, fig.width=4}
library(ChIPpeakAnno)
bamfiles <- file.path(outPath,
                     c("NucleosomeFree.bam",
                     "mononucleosome.bam",
                     "dinucleosome.bam",
                     "trinucleosome.bam"))
## Plot the cumulative percentage tag allocation in NucleosomeFree 
## and mononucleosome bams.
cumulativePercentage(bamfiles[1:2], as(seqinfo(Hsapiens)["chr1"], "GRanges"))
```
```{r fig.height=8, fig.width=4}
TSS <- promoters(txs, upstream=0, downstream=1)
TSS <- unique(TSS)
## estimate the library size for normalization
(librarySize <- estLibSize(bamfiles))
## calculate the signals around TSSs.
NTILE <- 101
dws <- ups <- 1010
sigs <- enrichedFragments(bamfiles, TSS=TSS,
                          librarySize=librarySize,
                          seqlev=seqlev,
                          TSS.filter=0.5,
                          n.tile = NTILE,
                          upstream = ups,
                          downstream = dws)
## log2 transformed signals
names(sigs) <- gsub(".bam", "", basename(names(sigs)))
sigs.log2 <- lapply(sigs, function(.ele) log2(.ele+1))
#plot heatmap
featureAlignedHeatmap(sigs.log2, reCenterPeaks(TSS, width=ups+dws),
                      zeroAt=.5, n.tile=NTILE)
```
```{r fig.show="hide"}
## get signals normlized for NucleosomeFree and nucleosome
out <- featureAlignedDistribution(sigs, 
                                  reCenterPeaks(TSS, width=ups+dws),
                                  zeroAt=.5, n.tile=NTILE, type="l")
```
```{r}
## rescale the NucleosomeFree and nucleosome signals to 0~1
range01 <- function(x){(x-min(x))/(max(x)-min(x))}
out <- apply(out, 2, range01)
matplot(out, type="l", xaxt="n", 
        xlab="Position (bp)", 
        ylab="Fraction of signal")
axis(1, at=seq(0, 100, by=10)+1, 
     labels=c("-1K", seq(-800, 800, by=200), "1K"), las=3)
abline(v=seq(0, 100, by=10)+1, lty=2, col="gray")
```

## Footprints

ATAC-seq footprints infer factor occupancy genome wide. `factorFootprints` 
function use `matchPWM` to get the predicted binding sites of target TF and
then calculate coverage for those sites. A accumulated coverage cure from the
binding sites will be plotted to show the status of the occupancy genome wide.
Different from CENTIPEDE[@pique2011accurate], which applies a hierarchical 
Bayesian mixture model to infer regions of the genome that are bound by 
particular transcription factors, we did not apply any filter for the 
candidate binding sites (sites that match a certain position weight 
matrix (PWM)). `factorFootprints` function could also accept the possible 
binding sites as a GRanges object.

```{r}
## foot prints
library(MotifDb)
CTCF <- query(MotifDb, c("CTCF"))
CTCF <- as.list(CTCF)
print(CTCF[[1]], digits=2)
sigs <- factorFootprints(shiftedBamfile, pfm=CTCF[[1]], 
                         genome=genome,
                         min.score="95%", seqlev=seqlev,
                         upstream=100, downstream=100)
```
```{r fig.height=6, fig.width=4}
featureAlignedHeatmap(sigs$signal, feature.gr=sigs$bindingSites,
                      annoMcols="score", sortBy = "score", 
                      n.tile=ncol(sigs$signal[[1]]))

sigs$spearman.correlation
```



Here is the CTCF footprints for a bigger dataset.
![CTCF footprints](CTCFfootprints.png)

# Session Info
```{r sessionInfo}
sessionInfo()
```

# References
